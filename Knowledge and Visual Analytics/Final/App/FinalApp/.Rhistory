are integral to ensure access to safe, adequate, long-lasting
housing in a way that is not detrimental to the environment.
These should be reexamined in future studies.")
), # close Sidebar Panel for Tab 3
mainPanel(fluidRow( # Create main panel Tab 3
column(4, plotlyOutput("barcharthai")),
column(8, plotOutput("barproportionmsabymethod")),
h4("Populations by Method"),
h5("On the y-axis we have the total population in millions of people
for the selected method(s) of interest in the Total Population Estimates
box. It is also important to select the affordability set for the total
population. For the bar chart on the left it is represented as
less than 100 (LT100) or greater than
100 (GT100) for comparison to other method charts. In the stacked bar chart
on the right we see the proportion of the populations that are in affordable
and unaffordable MSA. For this proportion chart, we only show one method
at a time and it is controlled by the selection of the proportion of the
population method."),
h5("You will notice that while debts are included in this visual, none of
the population will be shown on the chart on the left because there is
no MSA that can afford to pay for both their consumer debts and obligations
as well as housing. Meanwhile, some methods perform better than our normal (HAI)
method at reducing the total population in the category LT100. There is natural
variation in the data set and many other factors to consider when evaluating if
a method performs better than the rest. We focus only on the total population here
and notice that if we lended leniently or adjusted income by inflation we would
achieve the best results. Now, realistically, these lenient lending practices are
what is thought to have caused the 2008 great recession so they are not necessarily
the best by other standards. Additionally, projecting inflation is also not likely
to be very accurate when adjusting a houshold's income. It would be similar to trying to
hit a moving target and might also produce unintended consequences of furthering inflation.
We consider another perspective."),
h5("For the realists among us, adjustments to qualifying or median individual income is more likely
with a rent (HAIRNT) and real-wage (HAIRW) methods. Examples of these adjustments already exist
and appear to paint a more valid picture when assessing affordability in MSA when compared to
the normal method (HAI). This is visualized best when the 3 methods are selected from the total
population estimates and the affordability set is LT100. In the HAIRNT method we include the price
of rent in income which incorporates values that more than 44 million people in the U.S. pay monthly.
Of those renters, 45% pay more than 30% of their monthly income to rent.
This prevalence is so high that financial institutions have updated their recommendations
for renters while mortgage recommendations remain the same. However, both have gotten more strict
in practices. This HAIRNT method, applies best in heavily populated or dense MSA which typically have
higher rents. The alternative for less populated, sparse MSA is the HAIRW. This method adjusts income by the cost
of living using a market basket of goods and services from the Bureau of Labor Statistics and the Bureau of Economic
Analysis. Since it is typical that the prices of goods and services are lower in less populated MSA, this
gives a boost to the affordability of locations outside of locations that HAIRNT performs best in.
")
) # Close mainPanel fluidRow
) # Close main panel
) # End Tab 3 Sidebar Layout
), # End Tab 3
# Start Tab 4
tabPanel("Income", fluid = TRUE,
sidebarLayout(
sidebarPanel( # Create Sidebar Panel
selectizeInput(
inputId = "Statisticdftbl",
label = "Select Statistic",
choices = unique(df.tbl$Statistic),
selected = "Income Per Capita",
multiple = F),
h4("Summary"),
h5("Income is the primary variable with which an individual
can hope to improve their affordability of housing. However,
we know simply increasing our income is easier said than done.
It is better to know how much income should increase to be in
an affordable position regardless of MSA. It is also reasonable
to wonder how many people are present in an area and assess your
income relative to the median and minium income levels of those
in the same area. The closest local level in this analysis is the MSA but
this contains 83% of the U.S. population and serves as a good indicator of
overall income trends in the country. We break down the statistics by boxplot
and scatterplot and let you assess how income has changed since 2009."),
h5("By default, we start with Income per capita in each MSA and see a stretched
maximum box in green and condensed minimum blue box. If we select either
personal income or population, we notice the other median and minimums seem flat.
To see the other median and minimum for these categories the max and/or median traces
must be hidden.")
), # close Sidebar Panel for Tab 5
mainPanel(fluidRow( # Create main panel Tab 5
column(4, plotlyOutput("boxplotincome")),
column(8, plotlyOutput("plotincome2")),
h4("Income and Affordability"),
h5("Within an HAI, income is the primary statistic by which
an individual can improve the circumstances surrounding
their own affordability challenges. However, there are
macroeconomic forces that show wealth inequality increasing
across the entire United States, which lowers individuals'
chances of affording homes. Of course, there will still be
individuals who can afford more expensive homes because
the wealth still exists to afford them. It is just concentrated
among fewer individuals. But, since there are still individuals
available to purchase less affordable homes, prices will
continue to increase at a steady rate."),
h5("This can be seen directly as the growing distance between minimum
and maximum values over time. To visualize, when selecting the statistic,
choose either income per capita or personal income. Deselect
traces one at a time to isolate the minimum, median, and maximum
trends. Notice the differences in the boxplot height, medians,
and quartiles. The maximum value is stretching upwards while
the minimum box appears compressed. The scatterplot on the
right shows just how far the maximum income is from the minimum.
Our median exists much closer to the minimum in all years but
especially in the last decade compared to that of 1970. For
personal income and population, we have no choice but to isolate
each trace. Otherwise, the values appear flat when in fact,
they are not!"),
h5("The bottom line, this spreading of income between the highest earners
and lowest earners hurts individuals' chances of affording homes.
Quite simply, it is due to a widening of the home affordability
gap by decreasing the number of people with enough income to
afford the median home value. Referring to manipulations in
the standard National Association of Realtors equation, we
know that if enough people in the U.S. were to increase their
income, it would take time for median home values to catch up
and more homes would be affordable. However, what we notice is
the opposite. Based solely on historical earnings, if people
are not increasing their income then fewer people will be able
to afford housing.")
) # Close mainPanel fluid Row
) # Close main panel
) # End Tab 4 Sidebar Layout
),
# Start tab 5
tabPanel("Tables", fluid = TRUE,
sidebarLayout(
sidebarPanel( # Create sidebar panel for Tab 5
selectizeInput(
inputId = "haitablestab",
label = "Select Method",
choices = unique(ltdf$key),
selected = "HAI",
multiple = F),
selectizeInput(
inputId = "dffingeoname",
label = "Select MSA",
choices = unique(df.fin$GeoName),
selected = "New York-Newark-Jersey City, NY-NJ-PA (Metropolitan Statistical Area)",
multiple = T),
h4("Summary"),
h5("This section includes organized tables for referencing. The limiting
factor in this study was our earliest year 2009-2010 when several MSA were
missing values. This dropped our total MSA count to 539. Those listed in the
All tab show every HAI value and corresponding statistic for each year in the
study (2009 through 2019). Those listed as unaffordable contain values determined by the
normal HAI method to be less than affordable (or less than 100) and those that are listed as affordable
were determined by the same method but were greater than or equal to 100. Filtering
is allowed and selections can be made for HAI method and specific MSA.")
), # Close sidebar panel for tab 5
mainPanel(
tabsetPanel(type = "tabs",
tabPanel("All", dataTableOutput("alltable")),
tabPanel("Unaffordable", dataTableOutput("ltdftable")),
tabPanel("Affordable", dataTableOutput("gtdftable"))
)
)
)
)
)
)
# Define server functions
server <- function(input, output){
output$map <- renderPlotly({
dmap %>%
filter(Year == input$mapyear) %>%
plot_ly(.) %>%
add_trace(
type="choropleth",
geojson=counties,
locations= ~GeoFips,
z= ~Value,
colorscale= input$mapcolor,
zmin=0,
zmax=100000,
text = ~hover,
marker=list(line=list(
width=0))) %>%
colorbar(title = "Salary") %>%
layout(title = "U.S. Median Income Per Capita") %>%
layout(geo = g)
})
# Method Tab
output$method1 <- renderPlot({
method_function <- switch(input$method_geom_function,
boxplot = geom_boxplot,
density = geom_density,
hist = geom_histogram,
bar = geom_bar)
df_finkey %>%
filter(key == input$df_finkey_key) %>%
ggplot(aes(value, col = key)) +
method_function(alpha = .05) +
geom_vline(xintercept = 100) +
labs(subtitle = "Method Distributions", x = "Selected Statistic", y = "Count") +
theme(plot.subtitle = element_text(hjust = 0.5)) +
facet_wrap(~key, scales = "free_x", labeller = labeller(key = hainames)) +
theme(legend.position = "none",
panel.grid = element_blank())
})
output$method2 <- renderPlot({
# HAI Scatterplot Comparisson Plots
HAINAMES <- list("Normal" = "HAI", "Real Wage"="HAIRW", "Rent Adjustment"="HAIRNT",
"Inflation Adjusted"="HAIIPD", "Raw Values"="HAIRAW", "Lenient Lending"="HAILEN")
hainames <- c("HAI" = "Normal",
"HAIRW"="Real Wage",
"HAIRNT"="Rent Adjusted",
"HAIIPD"="Inflation Adjusted",
"HAIRAW"="Raw Values",
"HAILEN"="Lenient Lending")
HAItitle <- function(variable,value){
return(HAINAMES[value])
}
# Main 6 HAIs labeled Scatterplot Trends
main6 <- df.fin %>%
gather(key, value, -GeoFips, -GeoName, -year, -MEDINC,
-MEDVAL, -MOE, -UMEDVAL, -LMEDVAL, -POP, -PERINC, -AINCALL) %>%
filter(key == input$df_finkey_key) %>%
filter(AINCALL <100000) %>%
ggplot(aes(value, (AINCALL/1000))) +
geom_point(aes(x = value, alpha = .01, col = key)) +
geom_vline(xintercept = 100, lty = "dotdash", col = "black") +
geom_smooth(aes(x = value),
method="lm", col = "grey30", fill = "light grey",
se = T, na.rm = T) +
labs(x = "Home Affordability Value", y = "Income ($1000)",
subtitle = "Method Comparison to National Benchmark") +
facet_wrap(key ~ ., scales = "free_x", shrink = F, labeller = labeller(key = hainames)) +
theme(legend.position = "none",
plot.subtitle = element_text(hjust = 0.5),
panel.grid = element_blank())
# Outstanding Debts HAI ScatterPlot Trends
dbts1 <- df.fin %>%
gather(key, value, -GeoFips, -GeoName, -year, -MEDINC,
-MEDVAL, -MOE, -UMEDVAL, -LMEDVAL, -POP, -PERINC, -AINCALL) %>%
filter(key == c("HAIDBT")) %>%
filter(AINCALL <100000) %>%
ggplot(aes(value, (AINCALL/1000))) +
geom_point(aes(x = value, alpha = .01, col = key)) +
geom_vline(xintercept = 100, lty = "dotdash", col = "black") +
geom_smooth(aes(x = value),
method="loess", col = "grey30", fill = "light grey",
se = T, na.rm = T) +
labs(x = "Home Affordability Value", y = "Income ($1000)",
subtitle = "Debt Adjusted") +
theme(legend.position = "none",
plot.title = element_text(hjust = .5))
dbts2 <- df.fin %>%
gather(key, value, -GeoFips, -GeoName, -year, -MEDINC,
-MEDVAL, -MOE, -UMEDVAL, -LMEDVAL, -POP, -PERINC, -AINCALL) %>%
filter(key == c("HAIDBT")) %>%
filter(AINCALL <100000) %>%
ggplot(aes(value, (AINCALL/1000))) +
geom_point(aes(x = value, alpha = .01, col = key)) +
geom_smooth(aes(x = value),
method="loess", col = "grey30", fill = "light grey",
se = T, na.rm = T) +
labs(x = "Home Affordability Value", y = element_blank(),
subtitle = "Debt Adjusted Centered") +
theme(legend.position = "none",
plot.title = element_text(hjust = .5),
panel.grid.minor.y = element_blank())
# Arrange plots
ggarrange(main6,
ggarrange(dbts1, dbts2,
ncol=2, labels = c(" ", " ")),
nrow = 2, labels = " ")
})
output$method3 <- renderPlot({
MEGANAMES <- list("Affordable" = "GT100", "Unaffordable"="LT100")
meganames <- c("GT100" = "Affordable",
"LT100"="Unaffordable")
megatitles <- function(variable,value){
return(MEGANAMES[value])
}
# Megaplots
PMEDINC.median <- median(d$PMEDINC)
megaplot1 <- d %>%
sample_n(715, replace = T) %>%
filter(key == input$df_finkey_key) %>%
group_by(key, Set) %>%
arrange(desc(Set)) %>%
ggplot(aes(x = MMEDHAI, col = key)) + geom_point(aes(y = PMEDINC, col = key, size = 4)) +
geom_hline(yintercept = PMEDINC.median, lty = "dotted") +
geom_point(aes(y = PMEDINC)) +
facet_wrap(~Set, scales = "free_x", labeller = labeller(Set = meganames)) +
geom_smooth(aes(y = PMEDINC),
method="loess",
col = "grey30",
fill = "light grey",
se = T, na.rm = T,
lty = "solid") +
geom_smooth(aes(y = PMEDINC),
method="lm", alpha = 0.25,
col = "blue",
fill = "light blue",
se = F, na.rm = T,
lty = "dashed") +
labs(x = "Median HAI Value", y = "Median Income") +
theme(legend.position = "none", plot.title = element_blank())
megaplot2 <- d %>%
sample_n(715, replace = T) %>%
filter(key == input$df_finkey_key) %>%
group_by(key, Set) %>%
ggplot(aes(x = MMEDHAI, col = key)) + geom_point(aes(y = PMEDINC, col = key, size = 4)) +
geom_hline(yintercept = PMEDINC.median, lty = "dotted")  +
facet_wrap(~key, scales = "free", labeller = labeller(key = hainames)) +
geom_smooth(aes(y = PMEDINC),
method="loess",
col = "grey30",
fill = "light grey",
se = F, na.rm = T,
lty = "solid") +
geom_smooth(aes(y = PMEDINC),
method="lm", alpha = 0.25,
col = "blue",
fill = "light blue",
se = T, na.rm = T,
lty = "dashed") +
labs(x = element_blank(), y = "Median Income", subtitle = "Patterns in MSA by HAI Method") +
theme(legend.position = "none",
plot.subtitle = element_text(hjust=0.5))
ggarrange(megaplot2, megaplot1, nrow=2)
})
output$method4 <- renderPlot({
d %>%
sample_n(715, replace = T) %>%
filter(key == input$df_finkey_key) %>%
group_by(key, Set) %>%
ggplot(aes(x = year, col = key)) + geom_point(aes(y = PMEDINC, col = key)) +
geom_hline(yintercept = PMEDINC.median, lty = "dotted") +
geom_line(aes(y = PMEDINC)) +
facet_wrap(~Set, scales = "free", labeller = labeller(Set = meganames)) +
geom_smooth(aes(y = PMEDINC),
method="loess",
col = "grey30",
fill = "light grey",
se = T, na.rm = T,
lty = "solid") +
labs(x = element_blank(), y = "Median Income", subtitle = "Method Comparison for all MSA per Year") +
theme(legend.position = "none",
plot.subtitle = element_text(hjust = 0.5),
panel.grid.minor.x = element_blank(),
panel.grid.major.y = element_blank(),
panel.grid.minor.y = element_blank())
})
output$method4_5 <- renderPlot({
d %>%
sample_n(715, replace = T) %>%
filter(key == input$df_finkey_key) %>%
group_by(key, Set) %>%
ggplot(aes(x = year, col = key)) + geom_point(aes(y = MMEDHAI, col = key)) +
geom_hline(yintercept = 100,  lty = "dotted") +
geom_line(aes(y = MMEDHAI)) +
facet_wrap(~Set, scales = "fixed", labeller = labeller(Set = meganames)) +
geom_smooth(aes(y = MMEDHAI),
method="lm",
col = "grey30",
fill = "light grey",
se = T, na.rm = T,
lty = "solid") +
labs(x = element_blank(), y = "Median HAI", subtitle = "Method Comparison for all MSA per Year") +
theme(legend.position = "none",
plot.subtitle = element_text(hjust = 0.5),
panel.grid.minor.x = element_blank(),
panel.grid.major.y = element_blank(),
panel.grid.minor.y = element_blank())
})
output$method5 <- renderPlot({
d %>%
sample_n(715, replace = T) %>%
filter(key == input$df_finkey_key) %>%
group_by(key, Set) %>%
ggplot(aes(x = year, col = key)) + geom_point(aes(y = MMEDHAI, col = key)) +
geom_hline(yintercept = 100, lty = "dotted")  +
facet_wrap(~key, scales = "fixed", labeller = labeller(key = hainames)) +
geom_smooth(aes(y = MMEDHAI),
method="lm",
col = "grey30",
fill = "light blue",
se = T, na.rm = T,
lty = "solid") +
theme(legend.position = "none",
plot.subtitle = element_text(hjust = 0.5)) +
labs(x = element_blank(), y = "Median HAI",
subtitle = "Method Comparisson for all MSA by Year (Above and Below National Benchmark = 100)")
})
output$method6 <- renderPlot({
method_function <- switch(input$method_geom_function,
boxplot = geom_boxplot,
density = geom_density,
hist = geom_histogram,
bar = geom_bar)
df_types %>%
filter(Type == input$method6type) %>%
ggplot(aes(value, col = key, alpha = 0.05)) +
method_function() +
labs(subtitle = "Distribution", x = "Selected Statistic", y = "Count") +
theme(plot.subtitle = element_text(hjust = 0.5)) +
facet_wrap(~key, scales = "free") +
theme(legend.position = "none",
panel.grid = element_blank())
})
# Income Tab
output$boxplotincome <- renderPlotly({
df.tbl %>%
filter(Statistic == input$Statisticdftbl) %>%
plot_ly(., y = ~min, name = 'min', type = "box", boxpoints = "all", jitter = 0.75,
pointpos = 0,
marker = list(opacity = 0.5, color = 'rgb(17, 157, 255)', line = list(width = 2))) %>%
add_trace(y = ~med, name = 'med', boxpoints = "all", jitter = 0.3,
pointpos = 0,
marker = list(opacity = 0.5, color = 'rgb(17, 157, 255)', line = list(width = 2))) %>%
add_trace(y = ~max, name = 'max', boxpoints = "all", jitter = 0.3,
pointpos = 0,
marker = list(opacity = 0.5, color = 'rgb(17, 157, 255)', line = list(width = 2))) %>%
layout(yaxis = list(title = "Selected Statistic"))
})
output$plotincome2 <- renderPlotly({
df.tbl %>%
filter(Statistic == input$Statisticdftbl) %>%
plot_ly(., x = ~Years, y = ~min, name = "min", type = "scatter", mode = "lines+markers") %>%
add_trace(y = ~med, name = 'med', mode = 'lines+markers') %>%
add_trace(y = ~max, name = 'max', mode = 'lines+markers') %>%
layout(xaxis = list(title = "Year"),
yaxis = list(title = "Selected Statistic"))
})
# Population Tab
output$barproportionmsabymethod <- renderPlot({
d %>%
filter(key == input$barcharthaikey2) %>%
ggplot(aes(year, (TPOP/1000000), fill=Set)) +
geom_col(col = "grey38", alpha= 0.25) +
# scale_x_discrete(limit = c(2010, 2015, 2019)) +
labs(x = "Year (2010 - 2019)", y = "Population (Millions)", subtitle = "Proportion of MSA Population by Method") +
theme(axis.text.x = element_blank(),
# axis.ticks = element_line(size = .5),
plot.subtitle = element_text(hjust = 0.5)) +
facet_wrap(~key, scales = "fixed", labeller = labeller(key = hainames)) +
scale_fill_discrete(limits = c("LT100", "GT100"), labels = c("Unaffordable", "Affordable") )
})
output$barcharthai <- renderPlotly({
d %>%
filter(Set == input$barcharthaiset) %>%
filter(key %in% input$barcharthaikey) %>%
plot_ly(., x = ~year, y = ~(TPOP/1000000), type = "bar", name = ~key, opacity = 0.75) %>%
layout(yaxis = list(title = "Population (Millions)"))
})
# Tables Tab
output$ltdftable <- renderDataTable({
ltdf %>%
dplyr::select(GeoName, key, year, MEDINC, MEDVAL, MOE, POP, AINCALL, value) %>%
filter(key == input$haitablestab)
}, filter = 'top',
rownames = T)
output$gtdftable <- renderDataTable({
gtdf %>%
dplyr::select(GeoName, key, year, MEDINC, MEDVAL, MOE, POP, AINCALL, value) %>%
filter(key == input$haitablestab)
}, filter = 'top',
rownames = T)
output$alltable <- renderDataTable({
df.fin %>%
filter(GeoName == input$dffingeoname)
}, filter = "top",
rownames = F)
} # Close server
shinyApp(ui, server)
source("C:/Users/Zachary Palmore/GitHub/msds/Knowledge and Visual Analytics/Final/App/FinalApp/df_source.R") # Might take a minute
library(dplyr)
df.fin %>%
filter(HAI >= 110)
df.fin %>%
filter(GeoName == "Janesville-Beloit, WI (Metropolitan Statistical Area)")
df.fin %>%
filter(GeoName == "Janesville-Beloit, WI (Metropolitan Statistical Area)") %>% View()
df.fin %>%
filter(HAI >= 100) %>% View()
df.fin %>%
filter(HAI >= 100,
POP >= 500000) %>% View()
df.fin %>%
filter(HAI >= 100,
POP >= 500000,
year == 2019) %>% View()
df.fin %>%
filter(HAI >= 100,
POP >= 500000,
year == 2019) %>%
dplyr::select(GeoName, year, HAI)View()
df.fin %>%
filter(HAI >= 100,
POP >= 500000,
year == 2019) %>%
dplyr::select(GeoName, year, HAI) %>% View()
df.fin %>%
filter(HAI >= 100,
POP >= 500000,
year == 2019) %>%
dplyr::select(GeoName, year, HAI, HAIRW) %>% View()
df.fin %>%
filter(HAI >= 100,
POP >= 500000,
year == 2019) %>%
dplyr::select(GeoName, year, HAI, HAIRW, HAIRNT,) %>% View()
df.fin %>%
filter(HAI >= 110)
df.fin %>%
filter(HAI >= 100,
POP >= 500000,
year == 2019) %>%
dplyr::select(GeoName, year, POP, HAI, HAIRW, HAIRNT) %>% View()
library(shiny); runApp('FinalApp.R')
